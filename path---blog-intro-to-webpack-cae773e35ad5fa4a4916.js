webpackJsonp([45007803898617],{359:function(e,t){e.exports={data:{site:{meta:{title:"Kanishkar J",siteDescr:"Kanishkar J",siteUrl:"https://kanishkarj.github.com/",siteAuthor:"Kanishkar J",siteTwitterUrl:"https://twitter.com/_kanishkarj_",siteGithubUrl:"https://github.com/kanishkarj",siteEmailUrl:"kanishkarj@hotmail.com",siteGitconnectedUrl:"https://gitconnected.com/kanishkarj"}},markdownRemark:{id:"/home/kanishkarj/work/kanishkarj.github.io/src/pages/markdown/blog/webpack-30-1-2018/post.md absPath of file >>> MarkdownRemark",html:"<p>If you have worked on front end web development using frameworks like Vue, React or angular. You might have noticed most of the projects use a package called webpack. Webpack is a tool used to configure these front end libraries to work with your project files and aid in building the application. So in this series of posts we’ll see what is webpack and we’ll write a webpack configuration.</p>\n<h1>Introduction to Webpack</h1>\n<p>Webpack is a powerful module bundler that is used in frontend web development. By definition, a module bundler is a build tool that takes modules with dependencies and emits static assets representing those modules. When working on bigger projects, the codebase gets bigger and unmanageable over time. Hence to maintain the understandability and scalability of the code, we split the code into modules. A module bundler basically takes in all your modules and stitches them together into a single file.</p>\n<hr>\n<h2>Lets get started !</h2>\n<p>So before getting started with setting up Webpack, we need to understand the four Core Concepts of any Webpack configuration:</p>\n<ul>\n<li>Entry</li>\n<li>Output</li>\n<li>Loaders</li>\n<li>Plugins</li>\n</ul>\n<p>Now, lets get to them one by one!                </p>\n<h4>Entry</h4>\n<p>The entry point indicates the Module that Webpack will use to begin building the internal dependency graph. after entering the entry module, it will figure out other modules and libraries that the entry module uses. now, this process happens recursively. i.e every time a module is imported it will check on the other modules that it depends on and import them. hence, building up a dependency graph.</p>\n<h4>Output</h4>\n<p>The output point indicates the path to where the bundled code will be saved, and how it should be named.</p>\n<h4>Loaders</h4>\n<p>Loaders enable Webpack to process more than just JavaScript files. hence, using loaders we can bundle other files such as CSS, images etc. essentially all the files are converted to modules that can be included in the dependency graph.</p>\n<h4>Plugins</h4>\n<p>Plugins are kind of similar to modules, and it can be confusing sometimes to understand them. plugins basically can be used to perform a wider range of tasks. eg: file minification, bundle optimization. Loaders work at individual file level during or before the build. While Plugins are way more powerful than loaders. they can also modify how the bundles themselves are created.</p>\n<hr>\n<p>I have just briefly explained to you about Webpack and its Concepts. For more understanding, I would recommend you to configure Webpack from scratch.</p>",frontmatter:{path:"/blog/intro-to-webpack/",title:"Introduction to Webpack",subtitle:"Bundle your project with ease.",headerImg:"https://raw.githubusercontent.com/webpack/media/master/logo/logo-on-white-bg.png",date:"30 Jan, 2018"}}},pathContext:{}}}});
//# sourceMappingURL=path---blog-intro-to-webpack-cae773e35ad5fa4a4916.js.map